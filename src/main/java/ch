package main.java.chess.ai;

import main.java.chess.core.model.*;
import main.java.chess.core.evaluation.*;
import main.java.chess.core.config.*;
import main.java.chess.core.strategy.*;
import main.java.chess.core.exception.*;
import java.util.*;
import java.util.concurrent.*;

/**
 * Advanced Chess AI Engine with enterprise-level architecture
 * Implements minimax with alpha-beta pruning, transposition tables, and strategic evaluation
 */
public class AdvancedChessAI {
    
    private final AIStrategy strategy;
    private final PositionEvaluator evaluator;
    private final TranspositionTable transpositionTable;
    private final ExecutorService executorService;
    private final Random random;
    
    public AdvancedChessAI(AIConfiguration.Difficulty difficulty) {
        this.strategy = createStrategy(difficulty);
        this.evaluator = new PositionEvaluator();
        this.transpositionTable = new TranspositionTable(AIConfiguration.TRANSPOSITION_TABLE_SIZE);
        this.executorService = Executors.newFixedThreadPool(2);
        this.random = new Random();
    }
    
    /**
     * Creates an AI strategy based on difficulty level
     */
    private AIStrategy createStrategy(AIConfiguration.Difficulty difficulty) {
        return switch (difficulty) {
            case BEGINNER -> new BeginnerAIStrategy();
            case EASY -> new EasyAIStrategy();
            case MEDIUM -> new MediumAIStrategy();
            case HARD -> new HardAIStrategy();
            case EXPERT -> new ExpertAIStrategy();
        };
    }
    
    /**
     * Finds the best move for the given position
     */
    public CompletableFuture<Move> findBestMove(List<ChessPiece> pieces, PlayerColor aiColor) {
        return strategy.findBestMove(evaluator, generateLegalMoves(pieces, aiColor), 
                                   aiColor, detectGamePhase(pieces));
    }
    
    /**
     * Generates all legal moves for a given color
     */
    private List<Move> generateLegalMoves(List<ChessPiece> pieces, PlayerColor color) {
        List<Move> moves = new ArrayList<>();
        
        for (ChessPiece piece : pieces) {
            if (piece.getColor() == color) {
                moves.addAll(generateMovesForPiece(piece, pieces));
            }
        }
        
        return moves;
    }
    
    /**
     * Generates moves for a specific piece
     */
    private List<Move> generateMovesForPiece(ChessPiece piece, List<ChessPiece> pieces) {
        List<Move> moves = new ArrayList<>();
        Position currentPos = piece.getPosition();
        
        // Generate moves based on piece type
        switch (piece.getType()) {
            case PAWN:
                moves.addAll(generatePawnMoves(piece, pieces));
                break;
            case KNIGHT:
                moves.addAll(generateKnightMoves(piece, pieces));
                break;
            case BISHOP:
                moves.addAll(generateBishopMoves(piece, pieces));
                break;
            case ROOK:
                moves.addAll(generateRookMoves(piece, pieces));
                break;
            case QUEEN:
                moves.addAll(generateQueenMoves(piece, pieces));
                break;
            case KING:
                moves.addAll(generateKingMoves(piece, pieces));
                break;
        }
        
        return moves;
    }
    
    private List<Move> generatePawnMoves(ChessPiece piece, List<ChessPiece> pieces) {
        List<Move> moves = new ArrayList<>();
        Position pos = piece.getPosition();
        int direction = piece.getColor() == PlayerColor.WHITE ? -1 : 1;
        
        // Forward move
        Position forwardPos = pos.add(direction, 0);
        if (isValidPosition(forwardPos) && !isOccupied(forwardPos, pieces)) {
            moves.add(new Move(pos, forwardPos, piece.getType(), piece.getColor()));
            
            // Two squares forward from starting position
            if (!piece.hasMoved()) {
                Position twoForwardPos = pos.add(direction * 2, 0);
                if (isValidPosition(twoForwardPos) && !isOccupied(twoForwardPos, pieces)) {
                    moves.add(new Move(pos, twoForwardPos, piece.getType(), piece.getColor()));
                }
            }
        }
        
        // Captures
        for (int dc : Arrays.asList(-1, 1)) {
            Position capturePos = pos.add(direction, dc);
            if (isValidPosition(capturePos)) {
                ChessPiece target = getPieceAt(capturePos, pieces);
                if (target != null && target.getColor() != piece.getColor()) {
                    moves.add(new Move(pos, capturePos, piece.getType(), piece.getColor(), 
                                     true, false, false, false, false, null));
                }
            }
        }
        
        return moves;
    }
    
    private List<Move> generateKnightMoves(ChessPiece piece, List<ChessPiece> pieces) {
        List<Move> moves = new ArrayList<>();
        Position pos = piece.getPosition();
        int[] knightMoves = {-2, -1, 1, 2};
        
        for (int dr : knightMoves) {
            for (int dc : knightMoves) {
                if (Math.abs(dr) != Math.abs(dc)) {
                    Position targetPos = pos.add(dr, dc);
                    if (isValidPosition(targetPos)) {
                        ChessPiece target = getPieceAt(targetPos, pieces);
                        if (target == null || target.getColor() != piece.getColor()) {
                            moves.add(new Move(pos, targetPos, piece.getType(), piece.getColor(),
                                             target != null, false, false, false, false, null));
                        }
                    }
                }
            }
        }
        
        return moves;
    }
    
    private List<Move> generateBishopMoves(ChessPiece piece, List<ChessPiece> pieces) {
        return generateSlidingMoves(piece, pieces, Arrays.asList(
            Arrays.asList(-1, -1), Arrays.asList(-1, 1),
            Arrays.asList(1, -1), Arrays.asList(1, 1)
        ));
    }
    
    private List<Move> generateRookMoves(ChessPiece piece, List<ChessPiece> pieces) {
        return generateSlidingMoves(piece, pieces, Arrays.asList(
            Arrays.asList(-1, 0), Arrays.asList(1, 0),
            Arrays.asList(0, -1), Arrays.asList(0, 1)
        ));
    }
    
    private List<Move> generateQueenMoves(ChessPiece piece, List<ChessPiece> pieces) {
        List<Move> moves = new ArrayList<>();
        moves.addAll(generateBishopMoves(piece, pieces));
        moves.addAll(generateRookMoves(piece, pieces));
        return moves;
    }
    
    private List<Move> generateKingMoves(ChessPiece piece, List<ChessPiece> pieces) {
        List<Move> moves = new ArrayList<>();
        Position pos = piece.getPosition();
        
        for (int dr = -1; dr <= 1; dr++) {
            for (int dc = -1; dc <= 1; dc++) {
                if (dr != 0 || dc != 0) {
                    Position targetPos = pos.add(dr, dc);
                    if (isValidPosition(targetPos)) {
                        ChessPiece target = getPieceAt(targetPos, pieces);
                        if (target == null || target.getColor() != piece.getColor()) {
                            moves.add(new Move(pos, targetPos, piece.getType(), piece.getColor(),
                                             target != null, false, false, false, false, null));
                        }
                    }
                }
            }
        }
        
        return moves;
    }
    
    private List<Move> generateSlidingMoves(ChessPiece piece, List<ChessPiece> pieces, 
                                          List<List<Integer>> directions) {
        List<Move> moves = new ArrayList<>();
        Position pos = piece.getPosition();
        
        for (List<Integer> direction : directions) {
            int dr = direction.get(0);
            int dc = direction.get(1);
            Position targetPos = pos.add(dr, dc);
            
            while (isValidPosition(targetPos)) {
                ChessPiece target = getPieceAt(targetPos, pieces);
                
                if (target == null) {
                    moves.add(new Move(pos, targetPos, piece.getType(), piece.getColor()));
                } else {
                    if (target.getColor() != piece.getColor()) {
                        moves.add(new Move(pos, targetPos, piece.getType(), piece.getColor(),
                                         true, false, false, false, false, null));
                    }
                    break; // Stop when we hit a piece
                }
                
                targetPos = targetPos.add(dr, dc);
            }
        }
        
        return moves;
    }
    
    private boolean isValidPosition(Position pos) {
        return pos.getRow() >= 0 && pos.getRow() < 8 && pos.getCol() >= 0 && pos.getCol() < 8;
    }
    
    private boolean isOccupied(Position pos, List<ChessPiece> pieces) {
        return getPieceAt(pos, pieces) != null;
    }
    
    private ChessPiece getPieceAt(Position pos, List<ChessPiece> pieces) {
        for (ChessPiece piece : pieces) {
            if (piece.getPosition().equals(pos)) {
                return piece;
            }
        }
        return null;
    }
    
    /**
     * Detects the current game phase
     */
    private String detectGamePhase(List<ChessPiece> pieces) {
        int majorPieces = 0;
        for (ChessPiece piece : pieces) {
            if (piece.getType().isMajorPiece()) {
                majorPieces++;
            }
        }
        
        if (majorPieces > 6) {
            return AIConfiguration.GamePhase.OPENING.getDisplayName();
        } else if (majorPieces > 2) {
            return AIConfiguration.GamePhase.MIDDLEGAME.getDisplayName();
        } else {
            return AIConfiguration.GamePhase.ENDGAME.getDisplayName();
        }
    }
    
    /**
     * Performs minimax search with alpha-beta pruning
     */
    public int minimax(List<ChessPiece> pieces, int depth, int alpha, int beta, 
                     boolean isMaximizing, PlayerColor aiColor) {
        if (depth == 0) {
            return evaluator.evaluatePosition(pieces, aiColor);
        }
        
        // Check transposition table
        long positionHash = generatePositionHash(pieces, aiColor);
        var entry = transpositionTable.get(positionHash);
        if (entry != null && entry.depth >= depth) {
            return entry.score;
        }
        
        List<Move> moves = generateLegalMoves(pieces, isMaximizing ? aiColor : aiColor.opposite());
        
        if (moves.isEmpty()) {
            // Checkmate or stalemate
            if (isKingInCheck(pieces, aiColor)) {
                return isMaximizing ? -99999 + depth : 99999 - depth;
            }
            return 0; // Stalemate
        }
        
        int bestScore = isMaximizing ? Integer.MIN_VALUE : Integer.MAX_VALUE;
        
        for (Move move : moves) {
            List<ChessPiece> newPieces = applyMove(pieces, move);
            int score = minimax(newPieces, depth - 1, alpha, beta, !isMaximizing, aiColor);
            
            if (isMaximizing) {
                bestScore = Math.max(bestScore, score);
                alpha = Math.max(alpha, score);
            } else {
                bestScore = Math.min(bestScore, score);
                beta = Math.min(beta, score);
            }
            
            if (beta <= alpha) {
                break; // Alpha-beta pruning
            }
        }
        
        // Store in transposition table
        transpositionTable.put(positionHash, depth, bestScore, 
                             AIConfiguration.HASH_EXACT, 0);
        
        return bestScore;
    }
    
    private List<ChessPiece> applyMove(List<ChessPiece> pieces, Move move) {
        // Simplified move application - in a full implementation,
        // this would create new piece objects and handle special moves
        return pieces; // Placeholder
    }
    
    private boolean isKingInCheck(List<ChessPiece> pieces, PlayerColor color) {
        // Simplified check - would need proper implementation
        return false;
    }
    
    private long generatePositionHash(List<ChessPiece> pieces, PlayerColor color) {
        long hash = 0;
        for (ChessPiece piece : pieces) {
            hash = hash * 31 + piece.getType().ordinal() * 100 + 
                   piece.getColor().ordinal() * 10 + 
                   piece.getPosition().getRow() * 8 + piece.getPosition().getCol();
        }
        return hash * 31 + color.ordinal();
    }
    
    /**
     * Shuts down the AI engine
     */
    public void shutdown() {
        executorService.shutdown();
    }
    
    /**
     * Gets AI statistics
     */
    public Map<String, Object> getStatistics() {
        Map<String, Object> stats = new HashMap<>();
        stats.put("strategy", strategy.getName());
        stats.put("maxDepth", strategy.getMaxDepth());
        stats.put("transpositionTableSize", transpositionTable.getSize());
        stats.put("transpositionTableHitRate", transpositionTable.getHitRate());
        return stats;
    }
}